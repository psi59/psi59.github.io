<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Let's Encrypt로 https 서비스 하기 | Realsangil</title>
<meta name=keywords content="https,letsencrypt">
<meta name=description content="Let&rsquo;s Encrypt 공짜 SSL 인증서 발급하기!!">
<meta name=author content="박상일">
<link rel=canonical href=https://blog.realsangil.net/posts/2017-03-30-letsencrypt-certification-issue/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.realsangil.net/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://blog.realsangil.net/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://blog.realsangil.net/favicon-32x32.png>
<link rel=apple-touch-icon href=https://blog.realsangil.net/apple-touch-icon.png>
<link rel=mask-icon href=https://blog.realsangil.net/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.90.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MMTYEB98J6"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-MMTYEB98J6',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Let's Encrypt로 https 서비스 하기">
<meta property="og:description" content="Let&rsquo;s Encrypt 공짜 SSL 인증서 발급하기!!">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.realsangil.net/posts/2017-03-30-letsencrypt-certification-issue/">
<meta property="og:image" content="https://blog.realsangil.net/images/covers/letsencrypt.jpg"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-03-30T20:08:07+09:00">
<meta property="article:modified_time" content="2017-03-30T20:08:07+09:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://blog.realsangil.net/images/covers/letsencrypt.jpg">
<meta name=twitter:title content="Let's Encrypt로 https 서비스 하기">
<meta name=twitter:description content="Let&rsquo;s Encrypt 공짜 SSL 인증서 발급하기!!">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.realsangil.net/posts/"},{"@type":"ListItem","position":3,"name":"Let's Encrypt로 https 서비스 하기","item":"https://blog.realsangil.net/posts/2017-03-30-letsencrypt-certification-issue/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Let's Encrypt로 https 서비스 하기","name":"Let\u0027s Encrypt로 https 서비스 하기","description":"Let\u0026rsquo;s Encrypt 공짜 SSL 인증서 발급하기!!\n","keywords":["https","letsencrypt"],"articleBody":"Let’s Encrypt 공짜 SSL 인증서 발급하기!!\n시작하기 앞서 우선 이 포스트는 개인적으로 공부한 것을 정리하고 문서화 하기 위한 포스트이며 아웃사이더님의 글을 보고 참고한 것이 많습니다. 참고하면서 겪었던 시행착오들을 기억을 더듬어 정리한 것입니다. 부족한 부분이 있을 수 있으니 그 점을 감안하여 참고하시기 바랍니다.\n설치 환경 OS: CentOS7\nWEB SERVER: nginx\n인증서 발급 우선, 인증서를 발급받기 위해 certbot을 설치 해줍니다.\nyum install epel-release yum install certbot -y 공식 문서를 잘 보면 자동으로 인증해주는 방법도 있지만 이렇게 직접 해보는 방법도 공부라 생각하기에 이번 포스트에서는 직접 인증서를 발급 받도록 하겠습니다. 추후에 자동으로 발급받는 방법도 업데이트 하도록 하겠습니다.\n인증서를 발급받기 전에 사전 작업부터 해놓겠습니다.\nmkdir -p /home//www/.well-known/acem-challenge # 폴더 생성 후 nginx 설정 파일에 아래의 내용 입력  location /.well-known { root /home//www; } # 저장 후 꼭 리로드 다시 인증서를 발급하는 과정으로 넘어가겠습니다.\ncertbot certonly --manual 명령어를 입력하면 인증서 갱신이나 보안에 관련된 정보를 받을 수 있게 이메일을 입력하라고 나옵니다. 이메일 입력 후 진행\nEnter email address (used for urgent renewal and security notices) (Enter 'c' to cancel) : 이메일 주소 다음은 ACME 서버에 등록할 것인지 동의를 구하는 문구가 나오지만 사실 동의하지 않고 진행할 수 없기에 동의하고 진행\n----------------------------------------------------------------- Please read the Terms of Service at https://letsencrypt.org/documents/LE-SA-v1.1.1-August-1-2016.pdf. You must agree in order to register with the ACEM server at https://acme-v01.api.letsencrypt.org/directory ----------------------------------------------------------------- (A)gree/(C)ancel: A 다음은 방금 입력한 이메일로 메일을 보내도 되는지 묻지만 저는 받지 않도록 하겠습니다.\n--------------------------------------------------------------------------- Would you be willing to share your email address with the Electronic Frontier Foundation, a founding partner of the Let's Encrypt project and the non-profit organization that develops Certbot? We'd like to send you email about EFF and our work to encrypt the web, protect its users and defend digital rights. --------------------------------------------------------------------------- (Y)es/(N)o: N 등록할 도메인을 입력하고 진행(복수의 도메인을 입력할 경우 공백이나 콤마로 구분해주면 됩니다.)\nPlease enter in your domain name(s) (comma and/or space separated) (Enter 'c' to cancel): www.example.com 웹서버가 존재한다면 지정된 위치에 파일을 생성하면 되지만 웹서버가 없다면 사진 아래부분처럼 간단하게 웹서버를 만들 수 있도록 예시를 적어준 것입니다. 저는 웹서버가 있으니 새로운 쉘을 띄워 위에 그림의 밑줄 1번을 _파일명_으로 밑줄 2번을 _파일 내용_으로 입력하여 저장합니다.\n$ cat  /home//www/.well-known/acem-challenge/밑줄1 밑줄2 # ctrl + D 입력하여 저장 파일을 작성했다면 다시 인증서를 발급받던 쉘로 돌아와 enter를 눌러 진행하시면 됩니다. 이때 만약 서비스하려는 서버가 외부 접속을 막아놨다면 잠시 풀어주셔야 합니다. 왜냐하면 Let’s Encrypt가 http:///.well-known/acem-challenge/로 요청을 보내 파일이 존재하는지 파일 내용이 맞는지 인증하는 과정을 거치기 때문입니다.\n인증에 성공하면 위와 같이 인증서가 저장된 경로를 알려줍니다. 인증서를 발급받은 후 아래의 내용을 적절히 수정하여 nginx에 반영해주면 끝입니다. 아래의 내용은 Mozilla SSL Configuration Generator에서 생성할 수 있습니다.\nserver { listen 443 ssl; # certs sent to the client in SERVER HELLO are concatenated in ssl_certificate ssl_certificate /path/to/signed_cert_plus_intermediates; ssl_certificate_key /path/to/private_key; ssl_session_timeout 1d; ssl_session_cache shared:SSL:50m; ssl_session_tickets off; # Diffie-Hellman parameter for DHE ciphersuites, recommended 2048 bits ssl_dhparam /path/to/dhparam.pem; # intermediate configuration. tweak to your needs. ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS'; ssl_prefer_server_ciphers on; # HSTS (ngx_http_headers_module is required) (15768000 seconds = 6 months) add_header Strict-Transport-Security max-age=15768000; # OCSP Stapling --- # fetch OCSP records from URL in ssl_certificate and cache them ssl_stapling on; ssl_stapling_verify on; ## verify chain of trust of OCSP response using Root CA and Intermediate certs ssl_trusted_certificate /path/to/root_CA_cert_plus_intermediates; resolver 8.8.8.8 8.8.4.4 valid=86400; resolver_timeout 10; .... } 위의 코드에서 수정할 부분은\nssl_certificate /etc/letsencrypt/live//fullchain.pem; ssl_certificate_key /etc/letsencrypt/live//privkey.pem; ssl_dhparam /etc/letsencrypt/live//dhparam.pem; dhparam.pem는 **openssl dhparam -out dhparam.pem 2048**로 생성할 수 있습니다.\nssl_trusted_certificate /etc/letsencrypt/live//chain.pem; 위와 같이 수정하게 되면 대략 아래와 같은 내용이 완성됩니다.\nserver { ssl_certificate /etc/letsencrypt/live//fullchain.pem; ssl_certificate_key /etc/letsencrypt/live//privkey.pem; ssl_session_timeout 1d; ssl_session_cache shared:SSL:50m; ssl_session_tickets off; # Diffie-Hellman parameter for DHE ciphersuites, recommended 2048 bits ssl_dhparam /etc/letsencrypt/live//dhparam.pem; # intermediate configuration. tweak to your needs. ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS'; ssl_prefer_server_ciphers on; # HSTS (ngx_http_headers_module is required) (15768000 seconds = 6 months) add_header Strict-Transport-Security max-age=15768000; # OCSP Stapling --- # fetch OCSP records from URL in ssl_certificate and cache them ssl_stapling on; ssl_stapling_verify on; ## verify chain of trust of OCSP response using Root CA and Intermediate certs ssl_trusted_certificate /etc/letsencrypt/live//chain.pem; resolver 8.8.8.8 8.8.4.4 valid=86400; resolver_timeout 10; ... } 저장 후 nginx를 리로드 합니다.\n제대로 확인하고 따라했다면 이제 https를 반영한 도메인으로 접속하게되면 반영이 된 것을 확인 할 수 있다. 참고로 저는 창피하지만 아직 경험이 부족하다라는 핑계로 443포트를 열지 않아 왜 안되지 하고 있었습니다. 아직도 얼굴이 화끈거립니다. 이 글을 보는 분들은 이런 실수를 하지 않으셨으면 좋겠습니다.\n마치며 부족하지만 끝까지 읽어주셔서 감사하며 부족한 부분이나 궁금한 부분들은 댓글로 남겨주시거나 메일로 남겨주시면 서로 도움이 될거 같습니다. 감사합니다.\nReference  Lets' Encrypt로 무료로 HTTPS 지원하기 Let’s Encrypt 공식 사이트 ","wordCount":"736","inLanguage":"en","image":"https://blog.realsangil.net/images/covers/letsencrypt.jpg","datePublished":"2017-03-30T20:08:07+09:00","dateModified":"2017-03-30T20:08:07+09:00","author":{"@type":"Person","name":"박상일"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.realsangil.net/posts/2017-03-30-letsencrypt-certification-issue/"},"publisher":{"@type":"Organization","name":"Realsangil","logo":{"@type":"ImageObject","url":"https://blog.realsangil.net/favicon.ico"}}}</script>
</head>
<body id=top>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://blog.realsangil.net accesskey=h title="Realsangil (Alt + H)">Realsangil</a>
<span class=logo-switches>
</span>
</div>
<ul id=menu>
<li>
<a href=https://blog.realsangil.net/posts/ title=posts>
<span>posts</span>
</a>
</li>
<li>
<a href=https://blog.realsangil.net/tags/ title=tags>
<span>tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://blog.realsangil.net>Home</a>&nbsp;»&nbsp;<a href=https://blog.realsangil.net/posts/>Posts</a></div>
<h1 class=post-title>
Let's Encrypt로 https 서비스 하기
</h1>
<div class=post-meta><span title="2017-03-30 20:08:07 +0900 +0900">March 30, 2017</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;박상일
</div>
</header>
<figure class=entry-cover><img loading=lazy src=https://blog.realsangil.net/images/covers/letsencrypt.jpg alt>
</figure><div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%ec%8b%9c%ec%9e%91%ed%95%98%ea%b8%b0-%ec%95%9e%ec%84%9c aria-label="시작하기 앞서">시작하기 앞서</a></li>
<li>
<a href=#%ec%84%a4%ec%b9%98-%ed%99%98%ea%b2%bd aria-label="설치 환경">설치 환경</a></li>
<li>
<a href=#%ec%9d%b8%ec%a6%9d%ec%84%9c-%eb%b0%9c%ea%b8%89 aria-label="인증서 발급">인증서 발급</a></li>
<li>
<a href=#%eb%a7%88%ec%b9%98%eb%a9%b0 aria-label=마치며>마치며</a><ul>
<ul>
<li>
<a href=#reference aria-label=Reference>Reference</a>
</li>
</ul>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>Let&rsquo;s Encrypt 공짜 SSL 인증서 발급하기!!</p>
<h2 id=시작하기-앞서>시작하기 앞서<a hidden class=anchor aria-hidden=true href=#시작하기-앞서>#</a></h2>
<p>우선 이 포스트는 개인적으로 공부한 것을 정리하고 문서화 하기 위한 포스트이며 <a href="https://blog.outsider.ne.kr/1178?category=31">아웃사이더</a>님의 글을 보고 참고한 것이 많습니다. 참고하면서 겪었던 시행착오들을 기억을 더듬어 정리한 것입니다. 부족한 부분이 있을 수 있으니 그 점을 감안하여 참고하시기 바랍니다.</p>
<h2 id=설치-환경>설치 환경<a hidden class=anchor aria-hidden=true href=#설치-환경>#</a></h2>
<p>OS: CentOS7<br>
WEB SERVER: nginx</p>
<h2 id=인증서-발급>인증서 발급<a hidden class=anchor aria-hidden=true href=#인증서-발급>#</a></h2>
<p>우선, 인증서를 발급받기 위해 <a href=https://certbot.eff.org/>certbot</a>을 설치 해줍니다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>yum install epel-release
yum install certbot -y
</code></pre></div><p>공식 문서를 잘 보면 자동으로 인증해주는 방법도 있지만 이렇게 직접 해보는 방법도 공부라 생각하기에 이번 포스트에서는 직접 인증서를 발급 받도록 하겠습니다.
<em>추후에 자동으로 발급받는 방법도 업데이트 하도록 하겠습니다.</em></p>
<p>인증서를 발급받기 전에 사전 작업부터 해놓겠습니다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>mkdir -p /home/&lt;user계정&gt;/www/.well-known/acem-challenge  
<span style=color:#75715e># 폴더 생성 후 nginx 설정 파일에 아래의 내용 입력 </span>
location /.well-known <span style=color:#f92672>{</span>
  root /home/&lt;user계정&gt;/www;
<span style=color:#f92672>}</span>
<span style=color:#75715e># 저장 후 꼭 리로드</span>
</code></pre></div><p>다시 인증서를 발급하는 과정으로 넘어가겠습니다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>certbot certonly --manual
</code></pre></div><p>명령어를 입력하면 인증서 갱신이나 보안에 관련된 정보를 받을 수 있게 이메일을 입력하라고 나옵니다. 이메일 입력 후 진행</p>
<pre tabindex=0><code>Enter email address (used for urgent renewal and security notices)  
(Enter 'c' to cancel) : 이메일 주소
</code></pre><p>다음은 ACME 서버에 등록할 것인지 동의를 구하는 문구가 나오지만 사실 동의하지 않고 진행할 수 없기에 동의하고 진행</p>
<pre tabindex=0><code>-----------------------------------------------------------------
Please read the Terms of Service at  
https://letsencrypt.org/documents/LE-SA-v1.1.1-August-1-2016.pdf.   
You must agree in order to register with the ACEM server at  
https://acme-v01.api.letsencrypt.org/directory  
-----------------------------------------------------------------  
(A)gree/(C)ancel: A
</code></pre><p>다음은 방금 입력한 이메일로 메일을 보내도 되는지 묻지만 저는 받지 않도록 하겠습니다.</p>
<pre tabindex=0><code>---------------------------------------------------------------------------
Would you be willing to share your email address with the Electronic Frontier  
Foundation, a founding partner of the Let's Encrypt project and the non-profit
organization that develops Certbot? We'd like to send you email about EFF and  
our work to encrypt the web, protect its users and defend digital rights.  
---------------------------------------------------------------------------  
(Y)es/(N)o: N
</code></pre><p>등록할 도메인을 입력하고 진행(복수의 도메인을 입력할 경우 공백이나 콤마로 구분해주면 됩니다.)</p>
<pre tabindex=0><code>Please enter in your domain name(s) (comma and/or space separated)  
(Enter 'c' to cancel): www.example.com
</code></pre><p><img loading=lazy src=/images/2017-03-30-letsencrypt/1.png alt>
</p>
<p>웹서버가 존재한다면 지정된 위치에 파일을 생성하면 되지만 웹서버가 없다면 사진 아래부분처럼 간단하게 웹서버를 만들 수 있도록 예시를 적어준 것입니다. 저는 웹서버가 있으니 새로운 쉘을 띄워 위에 그림의 밑줄 1번을 _파일명_으로 밑줄 2번을 _파일 내용_으로 입력하여 저장합니다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ cat &gt; /home/&lt;user계정&gt;/www/.well-known/acem-challenge/밑줄1
밑줄2
<span style=color:#75715e># ctrl + D 입력하여 저장</span>
</code></pre></div><p>파일을 작성했다면 다시 인증서를 발급받던 쉘로 돌아와 enter를 눌러 진행하시면 됩니다.
이때 만약 서비스하려는 서버가 외부 접속을 막아놨다면 잠시 풀어주셔야 합니다. 왜냐하면
Let&rsquo;s Encrypt가 <code>http://&lt;발급하려는 도메인>/.well-known/acem-challenge/&lt;작성한 파일명></code>로 요청을 보내 파일이 존재하는지 파일 내용이 맞는지 인증하는 과정을 거치기 때문입니다.</p>
<p><img loading=lazy src=/images/2017-03-30-letsencrypt/2.png alt>
</p>
<p>인증에 성공하면 위와 같이 인증서가 저장된 경로를 알려줍니다.
인증서를 발급받은 후 아래의 내용을 적절히 수정하여 nginx에 반영해주면 끝입니다.
아래의 내용은 <a href=https://mozilla.github.io/server-side-tls/ssl-config-generator/>Mozilla SSL Configuration Generator</a>에서 생성할 수 있습니다.</p>
<pre tabindex=0><code>server {
    listen 443 ssl;

    # certs sent to the client in SERVER HELLO are concatenated in ssl_certificate
    ssl_certificate /path/to/signed_cert_plus_intermediates;
    ssl_certificate_key /path/to/private_key;
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    # Diffie-Hellman parameter for DHE ciphersuites, recommended 2048 bits
    ssl_dhparam /path/to/dhparam.pem;

    # intermediate configuration. tweak to your needs.
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS';
    ssl_prefer_server_ciphers on;

    # HSTS (ngx_http_headers_module is required) (15768000 seconds = 6 months)
    add_header Strict-Transport-Security max-age=15768000;

    # OCSP Stapling ---
    # fetch OCSP records from URL in ssl_certificate and cache them
    ssl_stapling on;
    ssl_stapling_verify on;

    ## verify chain of trust of OCSP response using Root CA and Intermediate certs
    ssl_trusted_certificate /path/to/root_CA_cert_plus_intermediates;

    resolver 8.8.8.8 8.8.4.4 valid=86400;
    resolver_timeout 10;

    ....
}
</code></pre><p>위의 코드에서 수정할 부분은</p>
<pre tabindex=0><code>ssl_certificate /etc/letsencrypt/live/&lt;인증서를 발급한 도메인&gt;/fullchain.pem;
ssl_certificate_key /etc/letsencrypt/live/&lt;인증서를 발급한 도메인&gt;/privkey.pem;
</code></pre><pre tabindex=0><code>ssl_dhparam /etc/letsencrypt/live/&lt;인증서를 발급한 도메인&gt;/dhparam.pem;
</code></pre><p><em>dhparam.pem는 **<code>openssl dhparam -out dhparam.pem 2048</code>**로 생성할 수 있습니다.</em></p>
<pre tabindex=0><code>ssl_trusted_certificate /etc/letsencrypt/live/&lt;인증서를 발급한 도메인&gt;/chain.pem;
</code></pre><p>위와 같이 수정하게 되면 대략 아래와 같은 내용이 완성됩니다.</p>
<pre tabindex=0><code>server {
    ssl_certificate /etc/letsencrypt/live/&lt;인증서를 발급한 도메인&gt;/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/&lt;인증서를 발급한 도메인&gt;/privkey.pem;
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    # Diffie-Hellman parameter for DHE ciphersuites, recommended 2048 bits
    ssl_dhparam /etc/letsencrypt/live/&lt;인증서를 발급한 도메인&gt;/dhparam.pem;

    # intermediate configuration. tweak to your needs.
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS';
    ssl_prefer_server_ciphers on;

    # HSTS (ngx_http_headers_module is required) (15768000 seconds = 6 months)
    add_header Strict-Transport-Security max-age=15768000;

    # OCSP Stapling ---
    # fetch OCSP records from URL in ssl_certificate and cache them
    ssl_stapling on;
    ssl_stapling_verify on;

    ## verify chain of trust of OCSP response using Root CA and Intermediate certs
    ssl_trusted_certificate /etc/letsencrypt/live/&lt;인증서를 발급한 도메인&gt;/chain.pem;

    resolver 8.8.8.8 8.8.4.4 valid=86400;
    resolver_timeout 10;

    ...
}
</code></pre><p>저장 후 nginx를 리로드 합니다.</p>
<p>제대로 확인하고 따라했다면 이제 https를 반영한 도메인으로 접속하게되면 반영이 된 것을 확인 할 수 있다.
참고로 저는 창피하지만 아직 경험이 부족하다라는 핑계로 443포트를 열지 않아 왜 안되지 하고 있었습니다. 아직도 얼굴이 화끈거립니다. 이 글을 보는 분들은 이런 실수를 하지 않으셨으면 좋겠습니다.</p>
<h2 id=마치며>마치며<a hidden class=anchor aria-hidden=true href=#마치며>#</a></h2>
<p>부족하지만 끝까지 읽어주셔서 감사하며 부족한 부분이나 궁금한 부분들은 댓글로 남겨주시거나 메일로 남겨주시면 서로 도움이 될거 같습니다. 감사합니다.</p>
<h4 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h4>
<ul>
<li><a href=https://blog.outsider.ne.kr/1178>Lets' Encrypt로 무료로 HTTPS 지원하기</a></li>
<li><a href=https://letsencrypt.org/>Let&rsquo;s Encrypt 공식 사이트</a></li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://blog.realsangil.net/tags/https/>https</a></li>
<li><a href=https://blog.realsangil.net/tags/letsencrypt/>letsencrypt</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://blog.realsangil.net/posts/2018-03-13-go-init-function/>
<span class=title>« Prev Page</span>
<br>
<span>Go의 init 함수 간단 소개!!</span>
</a>
<a class=next href=https://blog.realsangil.net/posts/2020-08-09-mitmproxy-installation/>
<span class=title>Next Page »</span>
<br>
<span>mitmproxy 설치하기</span>
</a>
</nav>
</footer><script src=https://utteranc.es/client.js repo=realsangil/realsangil.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://blog.realsangil.net>Realsangil</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>