<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>도커 컨테이너로 배포된 서버를 우아하게 종료하기✨ | Realsangil</title>
<meta name=keywords content="docker,golang">
<meta name=description content="프로덕션 환경에서 서버를 정상적으로 종료되는 것은 아주 중요합니다. 예를 들어 이미 수신한 요청을 온전히 처리하지 않고 서버가 종료될 때 클라이언트는 502나 504 에러를 수신하게 됩니다. 가장 기본적인 방법으로는 프로세스 종료 SIGNAL 수신 후 일정 시간을 기다린 후에 서버를 종료하는 방법이 있습니다.
서버 종료 요구사항 서버를 정상적으로 종료하기 위해서는 기본적으로 2가지의 요구사항이 존재합니다.
 서버가 종료될 때는 수신한 요청을 모두 응답한 후 종료. 서버가 닫힌 후에는 요청을 수신하면 안됨.  Go에서 Graceful Shutdown 구현하기 아래는 요청을 수신하고 5초 뒤 OK 메시지를 반환하는 간단한 예제 입니다.">
<meta name=author content="박상일">
<link rel=canonical href=https://blog.realsangil.net/posts/2020-11-14-docker-container-graceful-shutdown/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.realsangil.net/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://blog.realsangil.net/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://blog.realsangil.net/favicon-32x32.png>
<link rel=apple-touch-icon href=https://blog.realsangil.net/apple-touch-icon.png>
<link rel=mask-icon href=https://blog.realsangil.net/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.89.4">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-132761342-2','auto'),ga('send','pageview'))</script><meta property="og:title" content="도커 컨테이너로 배포된 서버를 우아하게 종료하기✨">
<meta property="og:description" content="프로덕션 환경에서 서버를 정상적으로 종료되는 것은 아주 중요합니다. 예를 들어 이미 수신한 요청을 온전히 처리하지 않고 서버가 종료될 때 클라이언트는 502나 504 에러를 수신하게 됩니다. 가장 기본적인 방법으로는 프로세스 종료 SIGNAL 수신 후 일정 시간을 기다린 후에 서버를 종료하는 방법이 있습니다.
서버 종료 요구사항 서버를 정상적으로 종료하기 위해서는 기본적으로 2가지의 요구사항이 존재합니다.
 서버가 종료될 때는 수신한 요청을 모두 응답한 후 종료. 서버가 닫힌 후에는 요청을 수신하면 안됨.  Go에서 Graceful Shutdown 구현하기 아래는 요청을 수신하고 5초 뒤 OK 메시지를 반환하는 간단한 예제 입니다.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.realsangil.net/posts/2020-11-14-docker-container-graceful-shutdown/">
<meta property="og:image" content="https://blog.realsangil.net/posts/2020-11-14-docker-container-graceful-shutdown/images/covers/docker.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-11-14T09:30:00+09:00">
<meta property="article:modified_time" content="2020-11-14T09:30:00+09:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://blog.realsangil.net/posts/2020-11-14-docker-container-graceful-shutdown/images/covers/docker.png">
<meta name=twitter:title content="도커 컨테이너로 배포된 서버를 우아하게 종료하기✨">
<meta name=twitter:description content="프로덕션 환경에서 서버를 정상적으로 종료되는 것은 아주 중요합니다. 예를 들어 이미 수신한 요청을 온전히 처리하지 않고 서버가 종료될 때 클라이언트는 502나 504 에러를 수신하게 됩니다. 가장 기본적인 방법으로는 프로세스 종료 SIGNAL 수신 후 일정 시간을 기다린 후에 서버를 종료하는 방법이 있습니다.
서버 종료 요구사항 서버를 정상적으로 종료하기 위해서는 기본적으로 2가지의 요구사항이 존재합니다.
 서버가 종료될 때는 수신한 요청을 모두 응답한 후 종료. 서버가 닫힌 후에는 요청을 수신하면 안됨.  Go에서 Graceful Shutdown 구현하기 아래는 요청을 수신하고 5초 뒤 OK 메시지를 반환하는 간단한 예제 입니다.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.realsangil.net/posts/"},{"@type":"ListItem","position":3,"name":"도커 컨테이너로 배포된 서버를 우아하게 종료하기✨","item":"https://blog.realsangil.net/posts/2020-11-14-docker-container-graceful-shutdown/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"도커 컨테이너로 배포된 서버를 우아하게 종료하기✨","name":"도커 컨테이너로 배포된 서버를 우아하게 종료하기✨","description":"프로덕션 환경에서 서버를 정상적으로 종료되는 것은 아주 중요합니다. 예를 들어 이미 수신한 요청을 온전히 처리하지 않고 서버가 종료될 때 클라이언트는 502나 504 에러를 수신하게 됩니다. 가장 기본적인 방법으로는 프로세스 종료 SIGNAL 수신 후 일정 시간을 기다린 후에 서버를 종료하는 방법이 있습니다.\n서버 종료 요구사항 서버를 정상적으로 종료하기 위해서는 기본적으로 2가지의 요구사항이 존재합니다.\n 서버가 종료될 때는 수신한 요청을 모두 응답한 후 종료. 서버가 닫힌 후에는 요청을 수신하면 안됨.  Go에서 Graceful Shutdown 구현하기 아래는 요청을 수신하고 5초 뒤 OK 메시지를 반환하는 간단한 예제 입니다.","keywords":["docker","golang"],"articleBody":"프로덕션 환경에서 서버를 정상적으로 종료되는 것은 아주 중요합니다. 예를 들어 이미 수신한 요청을 온전히 처리하지 않고 서버가 종료될 때 클라이언트는 502나 504 에러를 수신하게 됩니다. 가장 기본적인 방법으로는 프로세스 종료 SIGNAL 수신 후 일정 시간을 기다린 후에 서버를 종료하는 방법이 있습니다.\n서버 종료 요구사항 서버를 정상적으로 종료하기 위해서는 기본적으로 2가지의 요구사항이 존재합니다.\n 서버가 종료될 때는 수신한 요청을 모두 응답한 후 종료. 서버가 닫힌 후에는 요청을 수신하면 안됨.  Go에서 Graceful Shutdown 구현하기 아래는 요청을 수신하고 5초 뒤 OK 메시지를 반환하는 간단한 예제 입니다.\npackage main import ( \"context\" \"fmt\" \"net/http\" \"os\" \"os/signal\" \"syscall\" \"time\" ) func main() { h := \u0026HTTPHandler{} server := \u0026http.Server{Addr: \":1202\", Handler: h} if err := server.ListenAndServe(); err != nil { fmt.Printf(\"error: %v\\n\", err) } } type HTTPHandler struct{} func (h *HTTPHandler) ServeHTTP(res http.ResponseWriter, req *http.Request) { time.Sleep(5 * time.Second) res.WriteHeader(http.StatusOK) res.Write([]byte(\"OK\\n\")) } 서버 실행 후 curl를 통해 테스트 하면 5초 뒤 OK 메시지를 수신할 수 있습니다.\n이 때, 응답을 수신하기 전에 서버를 종료하는 경우를 테스트 해보겠습니다.\n❯ timeout 3 go run main.go \u0026 [1] 81662 ❯ time curl -v 'localhost:1202' * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 1202 (#0)  GET / HTTP/1.1  Host: localhost:1202  User-Agent: curl/7.64.1  Accept: */*  * Empty reply from server * Connection #0 to host localhost left intact curl: (52) Empty reply from server * Closing connection 0 curl -v 'localhost:1202' 0.00s user 0.00s system 0% cpu 2.241 total [1] + 81662 exit 124 timeout 3 go run main.go 결과를 보시면 서버와의 연결이 커맨드 실행을 수동으로 했기 때문에 약간의 오차가 있지만 3초(2.241초) 후에 종료 되었고 OK 메시지를 수신하지 못한 것을 확인할 수 있습니다.\nGraceful Shutdown이 적용된 HTTP Server Go에서는 기본적으로 graceful shutdown를 추가적인 라이브러리 없이 구현 가능합니다.\npackage main import ( \"context\" \"log\" \"net/http\" \"os\" \"os/signal\" \"syscall\" \"time\" ) var logger = log.New(os.Stdout, \"\", log.LstdFlags) func main() { h := \u0026HTTPHandler{} server := \u0026http.Server{Addr: \":1202\", Handler: h} // goroutine으로 서버 실행 \tgo func() { logger.Println(\"Start Server...\") if err := server.ListenAndServe(); err != nil { logger.Printf(\"error: %v\\n\", err) } }() // OS SIGNAL을 수신할 chanel 생성 \tsignalChan := make(chan os.Signal, 1) // KILL, INTERRUPT, QUIT, TERM SIGNAL 수신 등록 \tsignal.Notify( signalChan, os.Interrupt, os.Kill, syscall.SIGQUIT, // kill -SIGQUIT XXXX \tsyscall.SIGTERM, ) // SIGNAL 수신 \tsig := signalChan logger.Printf(\"Received SIGNAL: %v\\n\", sig) // timeout을 위한 context 생성 \tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() logger.Println(\"Close Server...\") // context에 지정한 timeout만큼 shutdown 지연 \tif err := server.Shutdown(ctx); err != nil { logger.Printf(\"error: %v\\n\", err) } } type HTTPHandler struct{} func (h *HTTPHandler) ServeHTTP(res http.ResponseWriter, req *http.Request) { logger.Println(\"Receive Request...\") time.Sleep(5 * time.Second) res.WriteHeader(http.StatusOK) res.Write([]byte(\"OK\\n\")) logger.Println(\"Send Response...\") } 변경된 코드에 대한 설명은 주석으로 간략하게 표현했습니다. 핵심적인 차이는 Server를 goroutine으로 실행하고 OS로부터 종료 SIGNAL을 수신하면 종료하는 부분입니다.\n이번에도 위와 동일하게 테스트를 해보겠습니다.\n❯ timeout 3 go run main.go 2020/11/09 09:18:06 Start Server... 2020/11/09 09:18:07 Receive Request... 2020/11/09 09:18:08 Received SIGNAL: terminated 2020/11/09 09:18:08 Close Server... 2020/11/09 09:18:08 error: http: Server closed ❯ time curl -v 'localhost:1202' * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 1202 (#0)  GET / HTTP/1.1  Host: localhost:1202  User-Agent: curl/7.64.1  Accept: */*  2020/11/08 20:40:23 Receive Request... 2020/11/08 20:40:25 Received SIGNAL: terminated 2020/11/08 20:40:25 Close Server... 2020/11/08 20:40:25 error: http: Server closed [1] + 35087 exit 124 timeout 3 go run main.go 2020/11/08 20:40:28 Send Response... 200 OK 08 Nov 2020 11:40:28 GMT 3 =utf-8 0 curl -v 'localhost:1202' 0.00s user 0.00s system 0% cpu 5.012 total curl의 로그와 섞여서 복잡하지만 로그를 보시면 서버는 이미 종료 되었지만 5초가 지난 후 성공적으로 응답을 수신한 것을 알 수 있습니다.\nDockerfile 작성 위에서 작성한 서버를 Docker image로 만들어 보겠습니다.\n# first.DockerfileFROMgolangLABEL maintainer=tkddlf59@gmail.comCOPY server /usr/bin/serverENTRYPOINT \"server\"# build docker image   docker build -t graceful_shutdown . # run docker container  docker run -d -p 1202:1202 --name graceful_shutdown . # stop container  docker stop graceful_shutdown \u0026 time curl -v 'localhost:1202' # log 확인  docker log graceful_shutdown 2020/11/08 23:53:35 Start Server... 2020/11/08 23:53:41 Receive Request... 2020/11/08 23:53:46 Send Response... 로그를 확인 해보면 도커는 안정적인 컨테이너를 종료를 위해 디폹트로 10초의 지연이 있습니다. 컨테어너 종료 지연 덕분에 응답은 정상적으로 반환 했지만 SIGNAL을 수신받지 못한 것을 알 수 있습니다. 이런 경우 발생할 수 있는 문제는 컨테이너가 완전히 종료되기 전까지는 요청을 계속해서 수신한다는 것입니다.\n그럼 이번에 Dokerfile의 ENTRYPOINT 부분을 조금 수정 해보겠습니다.\n# second.DockerfileFROMgolangLABEL maintainer=tkddlf59@gmail.comCOPY server /usr/bin/server# 수정된 부분ENTRYPOINT [\"server\"]새롭게 빌드 후 동일하게 테스트하면 서버가 정상적으로 종료 SIGNAL을 수신하고 서버를 종료하기 위해 Client의 요청을 Block하는 것을 확인할 수 있습니다.\ndocker에서는 ENTRYPOINT와 CMD를 exec-form(JSON array), **shell-form(문자열)**으로 처리합니다. exec-form은 exec 커맨드를 통해 실행 되지만 shell-form은 sh -c 커맨드를 통해 실행되기 때문에 SIGNAL을 전달 받을 수 없습니다. 그 외의 차이는 문서를 통해 확인하시면 되겠습니다.\n정리 이번 포스트에서는 Docker 컨테이너로 만든 Go 서버의 우아하게 종료하는 방법에 대해서 알아 보았습니다. 핵심은 서버가 Graceful Shutdown을 지원하더라도 Dockerfile을 작성할 때 ENTRYPOINT와 CMD를 exec-form으로 작성해야만 SIGNAL을 수신 받을 수 있다는 것입니다. 해당 코드는 Graceful Shutdown이 적용된 Go HTTP server · GitHub에서 확인가능합니다.\nReferences  Why Your Dockerized Application Isn’t Receiving Signals · Homepage of Hynek Schlawack Dockerfile feference - Entrypoint  ","wordCount":"843","inLanguage":"en","image":"https://blog.realsangil.net/posts/2020-11-14-docker-container-graceful-shutdown/images/covers/docker.png","datePublished":"2020-11-14T09:30:00+09:00","dateModified":"2020-11-14T09:30:00+09:00","author":{"@type":"Person","name":"박상일"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.realsangil.net/posts/2020-11-14-docker-container-graceful-shutdown/"},"publisher":{"@type":"Organization","name":"Realsangil","logo":{"@type":"ImageObject","url":"https://blog.realsangil.net/favicon.ico"}}}</script>
</head>
<body id=top>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://blog.realsangil.net accesskey=h title="Realsangil (Alt + H)">Realsangil</a>
<span class=logo-switches>
</span>
</div>
<ul id=menu>
<li>
<a href=https://blog.realsangil.net/posts/ title=posts>
<span>posts</span>
</a>
</li>
<li>
<a href=https://blog.realsangil.net/tags/ title=tags>
<span>tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://blog.realsangil.net>Home</a>&nbsp;»&nbsp;<a href=https://blog.realsangil.net/posts/>Posts</a></div>
<h1 class=post-title>
도커 컨테이너로 배포된 서버를 우아하게 종료하기✨
</h1>
<div class=post-meta><span title="2020-11-14 09:30:00 +0900 +0900">November 14, 2020</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;박상일
</div>
</header>
<figure class=entry-cover><img loading=lazy src=https://blog.realsangil.net/images/covers/docker.png alt="출처: docker.com">
<p>출처: docker.com</p>
</figure><div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%ec%84%9c%eb%b2%84-%ec%a2%85%eb%a3%8c-%ec%9a%94%ea%b5%ac%ec%82%ac%ed%95%ad aria-label="서버 종료 요구사항">서버 종료 요구사항</a></li>
<li>
<a href=#go%ec%97%90%ec%84%9c-graceful-shutdown-%ea%b5%ac%ed%98%84%ed%95%98%ea%b8%b0 aria-label="Go에서 Graceful Shutdown 구현하기">Go에서 Graceful Shutdown 구현하기</a><ul>
<li>
<a href=#graceful-shutdown%ec%9d%b4-%ec%a0%81%ec%9a%a9%eb%90%9c-http-server aria-label="Graceful Shutdown이 적용된 HTTP Server">Graceful Shutdown이 적용된 HTTP Server</a></li></ul>
</li>
<li>
<a href=#dockerfile-%ec%9e%91%ec%84%b1 aria-label="Dockerfile 작성">Dockerfile 작성</a></li>
<li>
<a href=#%ec%a0%95%eb%a6%ac aria-label=정리>정리</a></li>
<li>
<a href=#references aria-label=References>References</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>프로덕션 환경에서 서버를 정상적으로 종료되는 것은 아주 중요합니다.
예를 들어 이미 수신한 요청을 온전히 처리하지 않고 서버가 종료될 때 클라이언트는 <code>502</code>나 <code>504</code> 에러를 수신하게 됩니다.
가장 기본적인 방법으로는 프로세스 종료 SIGNAL 수신 후 일정 시간을 기다린 후에 서버를 종료하는 방법이 있습니다.</p>
<h2 id=서버-종료-요구사항>서버 종료 요구사항<a hidden class=anchor aria-hidden=true href=#서버-종료-요구사항>#</a></h2>
<p>서버를 정상적으로 종료하기 위해서는 기본적으로 2가지의 요구사항이 존재합니다.</p>
<ol>
<li>서버가 종료될 때는 수신한 요청을 모두 응답한 후 종료.</li>
<li>서버가 닫힌 후에는 요청을 수신하면 안됨.</li>
</ol>
<h2 id=go에서-graceful-shutdown-구현하기>Go에서 Graceful Shutdown 구현하기<a hidden class=anchor aria-hidden=true href=#go에서-graceful-shutdown-구현하기>#</a></h2>
<p>아래는 요청을 수신하고 5초 뒤 OK 메시지를 반환하는 간단한 예제 입니다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;context&#34;</span>
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;net/http&#34;</span>
	<span style=color:#e6db74>&#34;os&#34;</span>
	<span style=color:#e6db74>&#34;os/signal&#34;</span>
	<span style=color:#e6db74>&#34;syscall&#34;</span>
	<span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>h</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>HTTPHandler</span>{}
	<span style=color:#a6e22e>server</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Server</span>{<span style=color:#a6e22e>Addr</span>: <span style=color:#e6db74>&#34;:1202&#34;</span>, <span style=color:#a6e22e>Handler</span>: <span style=color:#a6e22e>h</span>}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>server</span>.<span style=color:#a6e22e>ListenAndServe</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;error: %v\n&#34;</span>, <span style=color:#a6e22e>err</span>)
	}
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>HTTPHandler</span> <span style=color:#66d9ef>struct</span>{}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>HTTPHandler</span>) <span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>res</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
	<span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusOK</span>)
	<span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;OK\n&#34;</span>))
}
</code></pre></div><p>서버 실행 후 <code>curl</code>를 통해 테스트 하면 5초 뒤 OK 메시지를 수신할 수 있습니다.</p>
<p>이 때, 응답을 수신하기 전에 서버를 종료하는 경우를 테스트 해보겠습니다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>❯ timeout <span style=color:#ae81ff>3</span> go run main.go &amp;
<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#ae81ff>81662</span>
❯ time curl -v <span style=color:#e6db74>&#39;localhost:1202&#39;</span>
*   Trying ::1...
* TCP_NODELAY set
* Connected to localhost <span style=color:#f92672>(</span>::1<span style=color:#f92672>)</span> port <span style=color:#ae81ff>1202</span> <span style=color:#f92672>(</span><span style=color:#75715e>#0)</span>
&gt; GET / HTTP/1.1
&gt; Host: localhost:1202
&gt; User-Agent: curl/7.64.1
&gt; Accept: */*
&gt;
* Empty reply from server
* Connection <span style=color:#75715e>#0 to host localhost left intact</span>
curl: <span style=color:#f92672>(</span>52<span style=color:#f92672>)</span> Empty reply from server
* Closing connection <span style=color:#ae81ff>0</span>
curl -v <span style=color:#e6db74>&#39;localhost:1202&#39;</span>  0.00s user 0.00s system 0% cpu 2.241 total
<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>  + <span style=color:#ae81ff>81662</span> exit <span style=color:#ae81ff>124</span>   timeout <span style=color:#ae81ff>3</span> go run main.go
</code></pre></div><p>결과를 보시면 서버와의 연결이 커맨드 실행을 수동으로 했기 때문에 약간의 오차가 있지만 3초(2.241초) 후에 종료 되었고 OK 메시지를 수신하지 못한 것을 확인할 수 있습니다.</p>
<h3 id=graceful-shutdown이-적용된-http-server>Graceful Shutdown이 적용된 HTTP Server<a hidden class=anchor aria-hidden=true href=#graceful-shutdown이-적용된-http-server>#</a></h3>
<p>Go에서는 기본적으로 graceful shutdown를 추가적인 라이브러리 없이 구현 가능합니다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;context&#34;</span>
	<span style=color:#e6db74>&#34;log&#34;</span>
	<span style=color:#e6db74>&#34;net/http&#34;</span>
	<span style=color:#e6db74>&#34;os&#34;</span>
	<span style=color:#e6db74>&#34;os/signal&#34;</span>
	<span style=color:#e6db74>&#34;syscall&#34;</span>
	<span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>logger</span> = <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stdout</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>LstdFlags</span>)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>h</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>HTTPHandler</span>{}
	<span style=color:#a6e22e>server</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Server</span>{<span style=color:#a6e22e>Addr</span>: <span style=color:#e6db74>&#34;:1202&#34;</span>, <span style=color:#a6e22e>Handler</span>: <span style=color:#a6e22e>h</span>}

	<span style=color:#75715e>// goroutine으로 서버 실행
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
		<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Start Server...&#34;</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>server</span>.<span style=color:#a6e22e>ListenAndServe</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;error: %v\n&#34;</span>, <span style=color:#a6e22e>err</span>)
		}
	}()
	<span style=color:#75715e>// OS SIGNAL을 수신할 chanel 생성
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>signalChan</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Signal</span>, <span style=color:#ae81ff>1</span>)
	<span style=color:#75715e>// KILL, INTERRUPT, QUIT, TERM SIGNAL 수신 등록
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>signal</span>.<span style=color:#a6e22e>Notify</span>(
		<span style=color:#a6e22e>signalChan</span>,
		<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Interrupt</span>,
		<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Kill</span>,
		<span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>SIGQUIT</span>, <span style=color:#75715e>// kill -SIGQUIT XXXX
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>SIGTERM</span>,
	)
	<span style=color:#75715e>// SIGNAL 수신
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>sig</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>signalChan</span>
	<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Received SIGNAL: %v\n&#34;</span>, <span style=color:#a6e22e>sig</span>)
	<span style=color:#75715e>// timeout을 위한 context 생성
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>cancel</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithTimeout</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(), <span style=color:#ae81ff>10</span><span style=color:#f92672>*</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>cancel</span>()
	<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Close Server...&#34;</span>)
	<span style=color:#75715e>// context에 지정한 timeout만큼 shutdown 지연
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>server</span>.<span style=color:#a6e22e>Shutdown</span>(<span style=color:#a6e22e>ctx</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;error: %v\n&#34;</span>, <span style=color:#a6e22e>err</span>)
	}
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>HTTPHandler</span> <span style=color:#66d9ef>struct</span>{}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>HTTPHandler</span>) <span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>res</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
	<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Receive Request...&#34;</span>)
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
	<span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusOK</span>)
	<span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;OK\n&#34;</span>))
	<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Send Response...&#34;</span>)
}
</code></pre></div><p>변경된 코드에 대한 설명은 주석으로 간략하게 표현했습니다.
핵심적인 차이는 Server를 goroutine으로 실행하고 OS로부터 종료 SIGNAL을 수신하면 종료하는 부분입니다.</p>
<p>이번에도 위와 동일하게 테스트를 해보겠습니다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>❯ timeout <span style=color:#ae81ff>3</span> go run main.go
2020/11/09 09:18:06 Start Server...
2020/11/09 09:18:07 Receive Request...
2020/11/09 09:18:08 Received SIGNAL: terminated
2020/11/09 09:18:08 Close Server...
2020/11/09 09:18:08 error: http: Server closed

❯ time curl -v <span style=color:#e6db74>&#39;localhost:1202&#39;</span>
*   Trying ::1...
* TCP_NODELAY set
* Connected to localhost <span style=color:#f92672>(</span>::1<span style=color:#f92672>)</span> port <span style=color:#ae81ff>1202</span> <span style=color:#f92672>(</span><span style=color:#75715e>#0)</span>
&gt; GET / HTTP/1.1
&gt; Host: localhost:1202
&gt; User-Agent: curl/7.64.1
&gt; Accept: */*
&gt;
2020/11/08 20:40:23 Receive Request...
2020/11/08 20:40:25 Received SIGNAL: terminated
2020/11/08 20:40:25 Close Server...
2020/11/08 20:40:25 error: http: Server closed
<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>  + <span style=color:#ae81ff>35087</span> exit <span style=color:#ae81ff>124</span>   timeout <span style=color:#ae81ff>3</span> go run main.go
2020/11/08 20:40:28 Send Response...
&lt; HTTP/1.1 <span style=color:#ae81ff>200</span> OK
&lt; Date: Sun, <span style=color:#ae81ff>08</span> Nov <span style=color:#ae81ff>2020</span> 11:40:28 GMT
&lt; Content-Length: <span style=color:#ae81ff>3</span>
&lt; Content-Type: text/plain; charset<span style=color:#f92672>=</span>utf-8
&lt; Connection: close
&lt;
OK
* Closing connection <span style=color:#ae81ff>0</span>
curl -v <span style=color:#e6db74>&#39;localhost:1202&#39;</span>  0.00s user 0.00s system 0% cpu 5.012 total
</code></pre></div><p><code>curl</code>의 로그와 섞여서 복잡하지만 로그를 보시면 서버는 이미 종료 되었지만 5초가 지난 후 성공적으로 응답을 수신한 것을 알 수 있습니다.</p>
<h2 id=dockerfile-작성>Dockerfile 작성<a hidden class=anchor aria-hidden=true href=#dockerfile-작성>#</a></h2>
<p>위에서 작성한 서버를 Docker image로 만들어 보겠습니다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#75715e># first.Dockerfile</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> golang</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>LABEL</span> maintainer<span style=color:#f92672>=</span>tkddlf59@gmail.com<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> server /usr/bin/server<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> <span style=color:#e6db74>&#34;server&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># build docker image </span>
&gt; docker build -t graceful_shutdown .
<span style=color:#75715e># run docker container</span>
&gt; docker run -d -p 1202:1202 --name graceful_shutdown .
<span style=color:#75715e># stop container</span>
&gt; docker stop graceful_shutdown &amp; time curl -v <span style=color:#e6db74>&#39;localhost:1202&#39;</span>
<span style=color:#75715e># log 확인</span>
&gt; docker log graceful_shutdown
2020/11/08 23:53:35 Start Server...
2020/11/08 23:53:41 Receive Request...
2020/11/08 23:53:46 Send Response...
</code></pre></div><p>로그를 확인 해보면 도커는 안정적인 컨테이너를 종료를 위해 디폹트로 10초의 지연이 있습니다. 컨테어너 종료 지연 덕분에 응답은 정상적으로 반환 했지만 SIGNAL을 수신받지 못한 것을 알 수 있습니다.
이런 경우 발생할 수 있는 문제는 컨테이너가 완전히 종료되기 전까지는 요청을 계속해서 수신한다는 것입니다.</p>
<p>그럼 이번에 Dokerfile의 <code>ENTRYPOINT</code> 부분을 조금 수정 해보겠습니다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#75715e># second.Dockerfile</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> golang</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>LABEL</span> maintainer<span style=color:#f92672>=</span>tkddlf59@gmail.com<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> server /usr/bin/server<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 수정된 부분</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;server&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>새롭게 빌드 후 동일하게 테스트하면 서버가 정상적으로 종료 SIGNAL을 수신하고 서버를 종료하기 위해 Client의 요청을 Block하는 것을 확인할 수 있습니다.</p>
<p>docker에서는 <code>ENTRYPOINT</code>와 <code>CMD</code>를 <strong>exec-form(JSON array)</strong>, **shell-form(문자열)**으로 처리합니다. exec-form은 <code>exec</code> 커맨드를 통해 실행 되지만 shell-form은 <code>sh -c</code> 커맨드를 통해 실행되기 때문에 SIGNAL을 전달 받을 수 없습니다. 그 외의 차이는 <a href=https://docs.docker.com/engine/reference/builder/#entrypoint>문서</a>를 통해 확인하시면 되겠습니다.</p>
<h2 id=정리>정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h2>
<p>이번 포스트에서는 Docker 컨테이너로 만든 Go 서버의 우아하게 종료하는 방법에 대해서 알아 보았습니다.
핵심은 서버가 Graceful Shutdown을 지원하더라도 Dockerfile을 작성할 때 <code>ENTRYPOINT</code>와 <code>CMD</code>를 exec-form으로 작성해야만 SIGNAL을 수신 받을 수 있다는 것입니다.
해당 코드는 <a href=https://gist.github.com/realsangil/3c6d71367a3f3f03d170c4655ee055a4>Graceful Shutdown이 적용된 Go HTTP server · GitHub</a>에서 확인가능합니다.</p>
<h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2>
<ul>
<li><a href=https://hynek.me/articles/docker-signals/>Why Your Dockerized Application Isn’t Receiving Signals · Homepage of Hynek Schlawack</a></li>
<li><a href=https://docs.docker.com/engine/reference/builder/#entrypoint>Dockerfile feference - Entrypoint</a></li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://blog.realsangil.net/tags/docker/>docker</a></li>
<li><a href=https://blog.realsangil.net/tags/golang/>golang</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://blog.realsangil.net/posts/2021-11-29-real-mysql-2/>
<span class=title>« Prev Page</span>
<br>
<span>[Real MySQL 8.0] #2 설치와 설정</span>
</a>
<a class=next href=https://blog.realsangil.net/posts/2020-02-06-concurrency-parallelism/>
<span class=title>Next Page »</span>
<br>
<span>Concurrency와 Parallelism의 차이</span>
</a>
</nav>
</footer><script src=https://utteranc.es/client.js repo=realsangil/realsangil.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://blog.realsangil.net>Realsangil</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>